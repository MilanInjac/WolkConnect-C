# WolkConnect-C
WolkAbout C Connector library for connecting devices to WolkAbout IoT platform.

WolkConnect-C is transportation layer agnostic which means it is up to the user of the library to
open socket to WolkAbout IoT platform, configure SSL if desired, and forward read/write implementation to WolkConnect-C.

This allows WolkConnect-C to work on wide variety of systems, bare metal to OS based ones.

Prerequisite
------
Following tools/libraries are required in order to build WolkAbout C connector

 * cmake

Former can be installed on Debian based system from terminal by invoking
`apt-get install cmake`

Afterwards dependencies are installed, Unix Makefiles build system can generated by invoking
`./configure`

Generated build system is located inside 'build' directory

WolkAbout C Connector library, and example are built from 'build' directory by invoking
`make` in terminal

Binary of example app is located in out/bin folder.

## Library usage
#### Setup
Edit device information

```
static const char *device_key = "device_key";
static const char *password = "password";

```

Set desired protocol

```
wolk_set_protocol (wolk_ctx_t *ctx, protocol_type_t protocol);
```

Connect to server

```
wolk_connect (wolk_ctx_t *ctx, send_func snd_func, recv_func rcv_func, const char *device_key, const char *password);
    send_buffer - function that will serve as callback when payload needs to be sent
    receive_buffer  - function that will serve as callback when data needs to be received from cloud
```

Set actuator references

```
wolk_set_actuator_references (wolk_ctx_t *ctx, int num_of_items, const char *item, ...);
```

When actuators are present, send initial actuator status to WolkAbout IoT platform
Depending on the actuator type following functions can be used:

```
wolk_publish_num_actuator_status (wolk_ctx_t *ctx,const char *reference,double value, actuator_status_t state, uint32_t utc_time);
```
```
wolk_publish_bool_actuator_status (wolk_ctx_t *ctx,const char *reference,bool value, actuator_status_t state, uint32_t utc_time);
```

#### Publishing data

Single readings
```
wolk_publish_single (wolk_ctx_t *ctx,const char *reference,const char *value, data_type_t type, uint32_t utc_time)
```

Aggregate readings
```
wolk_add_string_reading(wolk_ctx_t *ctx,const char *reference,const char *value, uint32_t utc_time);
wolk_add_numeric_reading(wolk_ctx_t *ctx,const char *reference,double value, uint32_t utc_time);
wolk_add_bool_reading(wolk_ctx_t *ctx,const char *reference,bool value, uint32_t utc_time);
wolk_publish (wolk_ctx_t *ctx);
```

#### Actuation

First process received commands with
```
wolk_receive (wolk_ctx_t *ctx, unsigned int timeout);
```
Then read actuation request
```
wolk_read_actuator (wolk_ctx_t *ctx, char *command, char *reference, char *value);
```

## Example
#### Setup connection
```
// Callback function:
// Socked 'sockfd' is opened at some point earlier
static int send_buffer(unsigned char* buffer, unsigned int len)
{
    int n = write(sockfd, buffer, len);
    if (n < 0)
        return -1;

    return n;
}

static int receive_buffer(unsigned char* buffer, unsigned int max_bytes)
{
    bzero(buffer, max_bytes);
    int n = read(sockfd, buffer, max_bytes);
    if (n < 0)
        return -1;

    return n;
}
// Callback functions

const char *device_key = "device_key";
const char *password = "password";

// Actuation variables
char reference[32];
char command [32];
char value[64];

wolk_ctx_t wolk;
wolk_set_protocol(&wolk, PROTOCOL_TYPE_JSON);

wolk_set_actuator_references (&wolk, 1, "Actuator reference");

wolk_publish_num_actuator_status (&wolk, "Actuator reference", value, ACTUATOR_STATUS_READY, current_time);

wolk_connect(&wolk, &send_buffer, &receive_buffer, device_key, password);
```
#### Publish data
```
wolk_publish_single (&wolk, "reference", "23.2", DATA_TYPE_NUMERIC, 0);
```

#### Actuation
```
wolk_receive (&wolk, timeout);
wolk_read_actuator (&wolk, command, reference, value);
```

**Note:** Example application contained in 'examples' folder is compatible with POSIX systems.
